<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
  body, html {
    margin: 0;
    padding: 0;
    /* Transparent background */
    background: rgba(0, 0, 0, 0);
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
<title>Fly-Through Universe (Transparent)</title>
</head>
<body>
<canvas id="myCanvas"></canvas>
<script>
//========================
// Configuration
//========================
const CONFIG = {
  focalLength: 200,
  numWords: 10,
  numStars: 50,
  startZ: -1000,
  resetZ: -50,
  fontBaseSize: 40,
  minSpeed: 1,
  maxSpeed: 5,
  starSize: 2,
  spawnRadius: 2000 // Large radius for spawning objects in a wide area
};

//========================
// Canvas & Basics
//========================
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function centerX() { return canvas.width / 2; }
function centerY() { return canvas.height / 2; }

//========================
// Utilities
//========================
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function pickRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateMathExpression() {
  // Simple sets of templates
  const singleLineNumeric = [
    // simple equalities
    () => {
      const a = randomInt(1,20), b = randomInt(1,20);
      return `${a}+${b}=${a+b}`;
    },
    () => {
      const a = randomInt(1,20), b = randomInt(1,20);
      return `${a}-${b}=${a-b}`;
    },
    () => {
      const a = randomInt(1,10), b = randomInt(1,10);
      return `${a}*${b}=${a*b}`;
    },
    () => {
      const a = randomInt(2,20), b = randomInt(1,10);
      return `${a}/${b}=${(a/b).toFixed(1)}`;
    },
    // inequalities
    () => {
      const a = randomInt(1,10), b = randomInt(1,10), c = randomInt(1,10), d = randomInt(1,10);
      return `${a}+${b}<${c}*${d}`;
    }
  ];

  const singleLineVars = [
    () => "x=y^2",
    () => "e=mc^2",
    () => {
      const a = randomInt(1,5), b = randomInt(1,5);
      return `x=${a}a+${b}`;
    },
    () => "a^2+b^2=c^2"
  ];

  // Two-line expressions
  const twoLine = [
    () => {
      const a = randomInt(1,10), b = randomInt(1,10);
      return `x=2a+${b}<br>x=a^3+2`;
    },
    () => {
      const a = randomInt(1,10), b = randomInt(1,10), c = randomInt(1,10);
      return `f(x)=x^2+${a}x+${b}<br>g(x)=${c}x+1`;
    },
    () => {
      const a = randomInt(1,10), b = randomInt(1,10);
      return `${a}+${b}=${a+b}<br>${a}*${b}=${a*b}`;
    }
  ];

  // Combine categories
  const categories = [
    ...singleLineNumeric,
    ...singleLineVars,
    ...twoLine
  ];

  // Randomly pick one pattern and generate expression
  const expressionFunc = pickRandom(categories);
  return expressionFunc();
}

function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// Given a radius, pick a random point inside a circle
// Using polar coordinates: radius * sqrt(rnd), angle = 2*pi*rnd ensures uniform distribution
function randomCirclePoint(maxRadius) {
  const r = Math.sqrt(Math.random()) * maxRadius;
  const angle = Math.random() * Math.PI * 2;
  const x = r * Math.cos(angle);
  const y = r * Math.sin(angle);
  return {x, y};
}

// Project a 3D point onto 2D screen
function project3D(x, y, z, focalLength) {
  const scale = focalLength / Math.abs(z);
  const screenX = centerX() + x * scale;
  const screenY = centerY() + y * scale;
  return { screenX, screenY, scale };
}

//========================
// Base class for objects
//========================
class SpaceObject {
  constructor() {
    this.reset();
  }

  reset() {
    const point = randomCirclePoint(CONFIG.spawnRadius);
    this.x = point.x;
    this.y = point.y;
    this.z = CONFIG.startZ;
    // We'll store a base speed for reference
    this.baseSpeed = randomRange(CONFIG.minSpeed, CONFIG.maxSpeed);
  }

  // Compute speed based on current z:
  // When far away (z ~ startZ), speed ~ baseSpeed
  // When close (z ~ resetZ), speed -> smaller fraction of baseSpeed
  getCurrentSpeed() {
    const distanceRange = Math.abs(CONFIG.startZ - CONFIG.resetZ);
    const currentDistance = Math.abs(this.z - CONFIG.resetZ);
    const fraction = currentDistance / distanceRange; // 1 at startZ, 0 near resetZ
    // Let's say speed can't drop below 20% of baseSpeed for readability
    const minFraction = 0.2;
    const adjustedFraction = fraction * (1 - minFraction) + minFraction; 
    return this.baseSpeed * adjustedFraction;
  }

  update() {
    const speed = this.getCurrentSpeed();
    this.z += speed;

    if (this.z > CONFIG.resetZ) {
      this.reset();
    }
  }
}

//========================
// Word class
//========================
class Word extends SpaceObject {
  constructor() {
    super();
    this.text = generateMathExpression();
    console.log("Generated word:", this.text);
  }

  reset() {
    super.reset();
    this.text = generateMathExpression();
    console.log("Generated word:", this.text);
  }

  draw(ctx) {
    const {screenX, screenY, scale} = project3D(this.x, this.y, this.z, CONFIG.focalLength);
    const fontSize = CONFIG.fontBaseSize * scale;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText(this.text, screenX, screenY);
  }
}

//========================
// Star class (no scaling in size, just position)
//========================
class Star extends SpaceObject {
  draw(ctx) {
    const {screenX, screenY} = project3D(this.x, this.y, this.z, CONFIG.focalLength);
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(screenX, screenY, CONFIG.starSize, 0, Math.PI*2);
    ctx.fill();
  }
}

//========================
// Initialization
//========================
const words = Array.from({length: CONFIG.numWords}, () => new Word());
const stars = Array.from({length: CONFIG.numStars}, () => new Star());

//========================
// Animation loop
//========================
function animate() {
  // Clear just the canvas; background is transparent
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update and draw stars
  for (const star of stars) {
    star.update();
    star.draw(ctx);
  }

  // Update and draw words
  for (const word of words) {
    word.update();
    word.draw(ctx);
  }

  requestAnimationFrame(animate);
}

// Start animation
animate();
</script>
</body>
</html>
