<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
  body, html {
    margin: 0;
    padding: 0;
    /* Transparent background */
    background: rgba(0, 0, 0, 0);
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
<title>Fly-Through Universe (Transparent)</title>
</head>
<body>
<canvas id="myCanvas"></canvas>
<script>
//========================
// Configuration
//========================
const CONFIG = {
  focalLength: 200,
  numWords: 10,
  numStars: 50,
  startZ: -1000,
  resetZ: -50,
  fontBaseSize: 40,
  minSpeed: 1,
  maxSpeed: 5,
  starSize: 2,
  spawnRadius: 2000 // Large radius for spawning objects in a wide area
};

//========================
// Canvas & Basics
//========================
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

function centerX() { return canvas.width / 2; }
function centerY() { return canvas.height / 2; }

//========================
// Utilities
//========================
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function pickRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateMathExpression() {
  // Single-line numeric expressions (each ≤ 10 chars)
  // Examples of length checks:
  // "1+2=3" -> 5 chars
  // "9-4=5" -> 5 chars
  // "2*3=6" -> 5 chars
  // "8/2=4" -> 5 chars
  // "3<2+2" -> 5 chars
  const singleLineNumeric = [
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `${a}+${b}=${a+b}`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `${a}-${b}=${a-b}`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `${a}*${b}=${a*b}`;
    },
    () => {
      const a = randomInt(2,9), b = randomInt(1,9);
      return `${a}/${b}=${Math.floor(a/b)}`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9), c = randomInt(1,9);
      return `${a}+${b}<${c}+${b}`;
    }
  ];

  // Single-line variables and constants (≤10 chars)
  // Check lengths:
  // "x=y^2" -> 5 chars
  // "e=mc^2" -> 7 chars
  // "x=2a+3" -> 7 chars if a ≤9
  // "x^2=9" -> 6 chars
  const singleLineVars = [
    () => "x=y^2",
    () => "e=mc^2",
    () => {
      const a = randomInt(1,9);
      const b = randomInt(1,9);
      return `x=${a}a+${b}`;
    },
    () => {
      const val = Math.pow(randomInt(2,4),2); // something small like 4,9,16
      return `x^2=${val}`;
    }
  ];

  // Two-line expressions (≤10 chars each line)
  // Check length:
  // "x=2a+3" -> 7 chars, "x=a^2+2" -> 7 chars
  // "f(x)=x^2" -> 8 chars, "g(x)=3x" -> 7 chars
  // "2+3=5" -> 5 chars, "3*3=9" -> 5 chars
  const twoLine = [
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `x=${a}a+${b}<br>x=a^2+2`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `f(x)=x^2<br>g(x)=${a}x+${b}`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `${a}+${b}=${a+b}<br>${a}*${b}=${a*b}`;
    }
  ];

  // Three-line expressions (each line ≤10 chars)
  // Simple enough so no line surpasses 10 chars:
  // "x=1", "y=2", "z=3" each are short.
  const threeLine = [
    () => {
      const a = randomInt(1,9), b = randomInt(1,9), c = randomInt(1,9);
      return `x=${a}<br>y=${b}<br>z=${c}`;
    },
    () => {
      const a = randomInt(1,9);
      return `x=a^2<br>x=${a}a<br>x=9`;
    },
    () => {
      const a = randomInt(1,9), b = randomInt(1,9);
      return `2+2=4<br>${a}=${a}<br>${b}*1=${b}`;
    }
  ];

  const categories = [
    ...singleLineNumeric,
    ...singleLineVars,
    ...twoLine,
    ...threeLine
  ];

  const expressionFunc = pickRandom(categories);
  return expressionFunc();
}


function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// Given a radius, pick a random point inside a circle
// Using polar coordinates: radius * sqrt(rnd), angle = 2*pi*rnd ensures uniform distribution
function randomCirclePoint(maxRadius) {
  const r = Math.sqrt(Math.random()) * maxRadius;
  const angle = Math.random() * Math.PI * 2;
  const x = r * Math.cos(angle);
  const y = r * Math.sin(angle);
  return {x, y};
}

// Project a 3D point onto 2D screen
function project3D(x, y, z, focalLength) {
  const scale = focalLength / Math.abs(z);
  const screenX = centerX() + x * scale;
  const screenY = centerY() + y * scale;
  return { screenX, screenY, scale };
}

//========================
// Base class for objects
//========================
class SpaceObject {
  constructor() {
    this.reset();
  }

  reset() {
    const point = randomCirclePoint(CONFIG.spawnRadius);
    this.x = point.x;
    this.y = point.y;
    this.z = CONFIG.startZ;
    // We'll store a base speed for reference
    this.baseSpeed = randomRange(CONFIG.minSpeed, CONFIG.maxSpeed);
  }

  // Compute speed based on current z:
  // When far away (z ~ startZ), speed ~ baseSpeed
  // When close (z ~ resetZ), speed -> smaller fraction of baseSpeed
  getCurrentSpeed() {
    const distanceRange = Math.abs(CONFIG.startZ - CONFIG.resetZ);
    const currentDistance = Math.abs(this.z - CONFIG.resetZ);
    const fraction = currentDistance / distanceRange; // 1 at startZ, 0 near resetZ
    // Let's say speed can't drop below 20% of baseSpeed for readability
    const minFraction = 0.2;
    const adjustedFraction = fraction * (1 - minFraction) + minFraction; 
    return this.baseSpeed * adjustedFraction;
  }

  update() {
    const speed = this.getCurrentSpeed();
    this.z += speed;

    if (this.z > CONFIG.resetZ) {
      this.reset();
    }
  }
}

//========================
// Word class
//========================
class Word extends SpaceObject {
  constructor() {
    super();
    this.prepareTextSprite();
  }

  reset() {
    super.reset();
    this.prepareTextSprite();
  }

  prepareTextSprite() {
    this.text = generateMathExpression();
    console.log("Generated word:", this.text);
    
    // Process multi-line text: replace <br> with \n, then split
    const lines = this.text.replace(/<br\s*\/?>/g, '\n').split('\n');

    // Use a baseline font (no scaling here, just a standard size)
    const fontSize = CONFIG.fontBaseSize;
    const lineHeight = fontSize * 1.2;
    const lineCount = lines.length;
    const totalHeight = lineCount * lineHeight;

    // Measure widest line to determine canvas width
    const offscreen = document.createElement('canvas');
    const offCtx = offscreen.getContext('2d');
    offCtx.font = `${fontSize}px sans-serif`;

    let maxWidth = 0;
    for (const line of lines) {
      const metrics = offCtx.measureText(line);
      const width = metrics.width;
      if (width > maxWidth) {
        maxWidth = width;
      }
    }

    // Add some padding
    const padding = 10;
    offscreen.width = Math.ceil(maxWidth + padding * 2);
    offscreen.height = Math.ceil(totalHeight + padding * 2);

    // Re-set font and styling after resizing canvas
    offCtx.font = `${fontSize}px sans-serif`;
    offCtx.textAlign = "center";
    offCtx.textBaseline = "middle";
    offCtx.fillStyle = "white";

    // Draw lines centered in offscreen canvas
    const centerX = offscreen.width / 2;
    let yPos = (offscreen.height / 2) - (totalHeight / 2) + (lineHeight / 2);

    for (const line of lines) {
      offCtx.fillText(line, centerX, yPos);
      yPos += lineHeight;
    }

    // Store the offscreen canvas as a sprite for later use
    this.textSprite = offscreen;
    this.spriteWidth = offscreen.width;
    this.spriteHeight = offscreen.height;
  }

  draw(ctx) {
    const {screenX, screenY, scale} = project3D(this.x, this.y, this.z, CONFIG.focalLength);

    // We have a pre-rendered sprite at baseline size
    // Original text drawn at fontSize = CONFIG.fontBaseSize
    // Now we scale the sprite by 'scale' to simulate perspective
    const drawWidth = this.spriteWidth * scale;
    const drawHeight = this.spriteHeight * scale;

    // Draw centered at (screenX, screenY)
    ctx.drawImage(
      this.textSprite,
      screenX - drawWidth / 2,
      screenY - drawHeight / 2,
      drawWidth,
      drawHeight
    );
  }
}


//========================
// Star class (no scaling in size, just position)
//========================
class Star extends SpaceObject {
  draw(ctx) {
    const {screenX, screenY} = project3D(this.x, this.y, this.z, CONFIG.focalLength);
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(screenX, screenY, CONFIG.starSize, 0, Math.PI*2);
    ctx.fill();
  }
}

//========================
// Initialization
//========================
const words = Array.from({length: CONFIG.numWords}, () => new Word());
const stars = Array.from({length: CONFIG.numStars}, () => new Star());

//========================
// Animation loop
//========================
function animate() {
  // Clear just the canvas; background is transparent
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Update and draw stars
  for (const star of stars) {
    star.update();
    star.draw(ctx);
  }

  // Update and draw words
  for (const word of words) {
    word.update();
    word.draw(ctx);
  }

  requestAnimationFrame(animate);
}

// Start animation
animate();
</script>
</body>
</html>
