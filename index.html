<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      /* Transparent background */
      background: rgba(0, 0, 0, 0);
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
  <title>Fly-Through Universe (Transparent)</title>
</head>

<body>
  <canvas id="myCanvas"></canvas>
  <script>
    //========================
    // Configuration
    //========================
    const CONFIG = {
      focalLength: 200,
      numWords: 10,
      numStars: 50,
      startZ: -1000,
      resetZ: -50,
      fontBaseSize: 40,
      minSpeed: 1,
      maxSpeed: 5,
      starSize: 2,
      spawnRadius: 2000 // Large radius for spawning objects in a wide area
    };

    //========================
    // Canvas & Basics
    //========================
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    function centerX() { return canvas.width / 2; }
    function centerY() { return canvas.height / 2; }

    //========================
    // Utilities
    //========================
    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function pickRandom(arr) {
      if (Math.random() < 1 / 2) {
      return arr[0];
      }
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function generateMathExpression() {
      // Simple numeric line expressions
      const singleLineNumeric = [
        // Original simple arithmetic
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `${a}+${b}=${a + b}`;
        },
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `${a}-${b}=${a - b}`;
        },
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `${a}*${b}=${a * b}`;
        },
        () => {
          const a = randomInt(2, 9), b = randomInt(1, 9);
          return `${a}/${b}=${Math.floor(a / b)}`;
        },
        // Original inequality template
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9), c = randomInt(1, 9);
          return `${a}+${b}<${c}+${b}`;
        },

        // New: Single relational operator between two numbers
        () => {
          const relOps = ['<', '>', '<=', '>=', '≈', '≠'];
          const op = pickRandom(relOps);
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `${a}${op}${b}`;
        },

        // New: Three-number expression with random arithmetic and a relational operator
        () => {
          const relOps = ['<', '>', '<=', '>=', '≈', '≠'];
          const op = pickRandom(relOps);
          const arithOps = ['+', '-', '*'];
          const op1 = pickRandom(arithOps);
          const op2 = pickRandom(arithOps);
          const a = randomInt(1, 9), b = randomInt(1, 9), c = randomInt(1, 9);
          // Various patterns to keep it interesting:
          const patterns = [
            `${a}${op1}${b}${op}${c}`,            // e.g. "3+4<7"
            `${a}${op1}${b}${op}${a + b}`,          // e.g. "2+3>5"
            `(${a}+${b})*${c}${op}${randomInt(1, 20)}`, // e.g. "(2+3)*4≤15"
            `${a}+${b}+${c}${op}${randomInt(1, 20)}`    // e.g. "2+2+5≈9"
          ];
          return pickRandom(patterns);
        },

        // New: Approximate operator with sum
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          const c = a + b + randomInt(-1, 1); // close to a+b
          return `${a}+${b}≈${c}`;
        }
      ];


      // Single-line STEM formulas (variety of physics, math constants)
      const singleLineVars = [
        () => "x=y^2",
        () => "E=mc^2",   // Einstein's energy-mass equivalence
        () => "F=ma",     // Newton's 2nd law
        () => "V=IR",     // Ohm's law
        () => "E=hv",     // Photon energy
        () => "π≈3.14"    // Approx value of pi
      ];

      // Two-line STEM expressions
      const twoLine = [
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `f(x)=x^2\ng(x)=${a}x+${b}`;
        },
        () => {
          const a = randomInt(1, 9), b = randomInt(1, 9);
          return `${a}+${b}=${a + b}\n${a}*${b}=${a * b}`;
        },
        () => {
          // Simple geometric relation and a small arithmetic line:
          return `a^2+b^2=c^2\nx^2=9`;
        }
      ];

      // Three-line sets with well-known STEM formulas
      const threeLine = [
        () => `F=ma\npV=nRT\nE=mc^2`,      // Physics & chemistry (Ideal gas law, Einstein's, Newton's)
        () => `V=IR\nP=IV\nE=hv`,          // Electronics & photon energy
        () => `c²=a²+b²\nx=2a+1\nπ≈3.14`   // Pythagorean theorem, simple linear eq, pi approximation
      ];

      const categories = [
        ...singleLineNumeric,
        ...singleLineVars,
        ...twoLine,
        ...threeLine
      ];

      const expressionFunc = pickRandom(categories);
      let expr = expressionFunc();

      // Randomly choose <br> or \n for multi-lines (to keep consistency we can just use \n)
      // We'll standardize on '\n' since we split by '\n' in rendering code.
      expr = expr.replace(/<br\s*\/?>/g, '\n');

      return expr;
    }


    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    // Given a radius, pick a random point inside a circle
    // Using polar coordinates: radius * sqrt(rnd), angle = 2*pi*rnd ensures uniform distribution
    function randomCirclePoint(maxRadius) {
      const r = Math.sqrt(Math.random()) * maxRadius;
      const angle = Math.random() * Math.PI * 2;
      const x = r * Math.cos(angle);
      const y = r * Math.sin(angle);
      return { x, y };
    }

    // Project a 3D point onto 2D screen
    function project3D(x, y, z, focalLength) {
      const scale = focalLength / Math.abs(z);
      const screenX = centerX() + x * scale;
      const screenY = centerY() + y * scale;
      return { screenX, screenY, scale };
    }

    //========================
    // Base class for objects
    //========================
    class SpaceObject {
      constructor() {
        this.reset();
      }

      reset() {
        const point = randomCirclePoint(CONFIG.spawnRadius);
        this.x = point.x;
        this.y = point.y;
        this.z = CONFIG.startZ;
        // We'll store a base speed for reference
        this.baseSpeed = randomRange(CONFIG.minSpeed, CONFIG.maxSpeed);
      }

      // Compute speed based on current z:
      // When far away (z ~ startZ), speed ~ baseSpeed
      // When close (z ~ resetZ), speed -> smaller fraction of baseSpeed
      getCurrentSpeed() {
        const distanceRange = Math.abs(CONFIG.startZ - CONFIG.resetZ);
        const currentDistance = Math.abs(this.z - CONFIG.resetZ);
        const fraction = currentDistance / distanceRange; // 1 at startZ, 0 near resetZ
        // Let's say speed can't drop below 20% of baseSpeed for readability
        const minFraction = 0.2;
        const adjustedFraction = fraction * (1 - minFraction) + minFraction;
        return this.baseSpeed * adjustedFraction;
      }

      update() {
        const speed = this.getCurrentSpeed();
        this.z += speed;

        if (this.z > CONFIG.resetZ) {
          this.reset();
        }
      }
    }

    //========================
    // Word class
    //========================
    class Word extends SpaceObject {
      constructor() {
        super();
        this.prepareTextSprite();
      }

      reset() {
        super.reset();
        this.prepareTextSprite();
      }

      prepareTextSprite() {
        this.text = generateMathExpression();
        console.log("Generated word:", this.text);

        // Process multi-line text: replace <br> with \n, then split
        const lines = this.text.replace(/<br\s*\/?>/g, '\n').split('\n');

        // Use a baseline font (no scaling here, just a standard size)
        const fontSize = CONFIG.fontBaseSize;
        const lineHeight = fontSize * 1.2;
        const lineCount = lines.length;
        const totalHeight = lineCount * lineHeight;

        // Measure widest line to determine canvas width
        const offscreen = document.createElement('canvas');
        const offCtx = offscreen.getContext('2d');
        offCtx.font = `${fontSize}px sans-serif`;

        let maxWidth = 0;
        for (const line of lines) {
          const metrics = offCtx.measureText(line);
          const width = metrics.width;
          if (width > maxWidth) {
            maxWidth = width;
          }
        }

        // Add some padding
        const padding = 10;
        offscreen.width = Math.ceil(maxWidth + padding * 2);
        offscreen.height = Math.ceil(totalHeight + padding * 2);

        // Re-set font and styling after resizing canvas
        offCtx.font = `${fontSize}px sans-serif`;
        offCtx.textAlign = "center";
        offCtx.textBaseline = "middle";
        offCtx.fillStyle = "white";

        // Draw lines centered in offscreen canvas
        const centerX = offscreen.width / 2;
        let yPos = (offscreen.height / 2) - (totalHeight / 2) + (lineHeight / 2);

        for (const line of lines) {
          offCtx.fillText(line, centerX, yPos);
          yPos += lineHeight;
        }

        // Store the offscreen canvas as a sprite for later use
        this.textSprite = offscreen;
        this.spriteWidth = offscreen.width;
        this.spriteHeight = offscreen.height;
      }

      draw(ctx) {
        const { screenX, screenY, scale } = project3D(this.x, this.y, this.z, CONFIG.focalLength);

        // We have a pre-rendered sprite at baseline size
        // Original text drawn at fontSize = CONFIG.fontBaseSize
        // Now we scale the sprite by 'scale' to simulate perspective
        const drawWidth = this.spriteWidth * scale;
        const drawHeight = this.spriteHeight * scale;

        // Draw centered at (screenX, screenY)
        ctx.drawImage(
          this.textSprite,
          screenX - drawWidth / 2,
          screenY - drawHeight / 2,
          drawWidth,
          drawHeight
        );
      }
    }

    //========================
    // Star class (no scaling in size, just position)
    //========================
    class Star extends SpaceObject {
      draw(ctx) {
        const { screenX, screenY } = project3D(this.x, this.y, this.z, CONFIG.focalLength);
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(screenX, screenY, CONFIG.starSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    //========================
    // Initialization
    //========================
    const words = Array.from({ length: CONFIG.numWords }, () => new Word());
    const stars = Array.from({ length: CONFIG.numStars }, () => new Star());

    //========================
    // Animation loop
    //========================
    function animate() {
      // Clear just the canvas; background is transparent
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Update and draw stars
      for (const star of stars) {
        star.update();
        star.draw(ctx);
      }

      // Update and draw words
      for (const word of words) {
        word.update();
        word.draw(ctx);
      }

      requestAnimationFrame(animate);
    }

    // Start animation
    animate();
  </script>
</body>

</html>